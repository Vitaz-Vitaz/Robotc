#pragma config(Sensor, S1,     ,               sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Sensor, S3,     ,               sensorEV3_Ultrasonic)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float S1_calibr(){
	float est = SensorRaw[S1];
	float minColor = 477;
	float maxColor = 660;
	return (est - minColor)/(maxColor - minColor) * 100;
}

float S2_calibr(){
	float est = SensorRaw[S2];
	float minColor = 477;
	float maxColor = 660;
	return (est - minColor)/(maxColor - minColor) * 100;
}

void proehat_gradusi(float power, int gradusi){
	float a = nMotorEncoder[motorB];
	while(nMotorEncoder[motorB] - a < gradusi){
		motor[motorB] = power;
		motor[motorC] = power;
	}
	motor[motorB] = 0;
	motor[motorC] = 0;
	sleep(1000);

}

void povernut_na90_gradusi(float power, int vpravo){
	if (vpravo){
				float a  = nMotorEncoder[motorC];
				while(abs(nMotorEncoder[motorC]) - a < 245){
				motor[motorB] = -power;
				motor[motorC] = power;
	        }
		motor[motorB] = 0;
		motor[motorC] = 0;
		sleep(1000);

	}
	else{float a  = nMotorEncoder[motorB];
	while(abs(nMotorEncoder[motorB]) - a < 245){
		motor[motorB] =  power;
		motor[motorC] = -power;
	};

	motor[motorB] = 0;
	motor[motorC] = 0;
	sleep(1000);}
}


void go_line(float power){
	float k = 0.7;
	float d = 7;
	float error = 0;
	float last_error = error;
	float l = S1_calibr();
	float r = S2_calibr();
	while(l < 90 || r < 90){
		l = S1_calibr();
		r = S2_calibr();
		error = l - r;

		float u = error * k + (error - last_error) * d;
		motor[motorB] = power + u;
		motor[motorC] = power - u;
		last_error = error;
	}


}

void go_line_gradusi(float power, float gradusi){
	float k = 0.7;
	float d = 7;
	float error = 0;
	float last_error = error;
	float l = S1_calibr();
	float r = S2_calibr();
	float a = nMotorEncoder[motorB];
	while(nMotorEncoder[motorB] - a < gradusi){
		l = S1_calibr();
		r = S2_calibr();
		error = l - r;
		displayBigTextLine(1, "%d", l);
		displayBigTextLine(1, "%d", r);
		float u = error * k + (error - last_error) * d;
		motor[motorB] = power + u;
		motor[motorC] = power - u;
		last_error = error;
	}


}

void go_line_cm(float power, float cm){
	float k = 0.7;
	float d = 7;
	float error = 0;
	float gradusi = cm / (2 * 3.14 * 2.8) *  360;
	float last_error = error;
	float l = S1_calibr();
	float r = S2_calibr();
	float a = nMotorEncoder[motorB];
	while(nMotorEncoder[motorB] - a < gradusi){
		l = S1_calibr();
		r = S2_calibr();
		error = l - r;
		displayBigTextLine(1, "%d", l);
		displayBigTextLine(1, "%d", r);
		float u = error * k + (error - last_error) * d;
		motor[motorB] = power + u;
		motor[motorC] = power - u;
		last_error = error;
	}


}

void go_line_time(float power, float time){
	float k = 0.7;
	float d = 7;
	float error = 0;

	float last_error = error;
	float l = S1_calibr();
	float r = S2_calibr();
	float a = nSysTime;
	while(nSysTime - a < time *  1000){
		l = S1_calibr();
		r = S2_calibr();
		error = l - r;
		displayBigTextLine(1, "%d", l);
		displayBigTextLine(1, "%d", r);
		float u = error * k + (error - last_error) * d;
		motor[motorB] = power + u;
		motor[motorC] = power - u;
		last_error = error;
	}


}

void go_line_doObject(float power, float mm){
	float k = 0.7;
	float d = 7;
	float error = 0;

	float last_error = error;
	float l = S1_calibr();
	float r = S2_calibr();

	while(SensorRaw[3] < mm){
		l = S1_calibr();
		r = S2_calibr();
		error = l - r;
		displayBigTextLine(1, "%d", SensorRaw[S3]);

		float u = error * k + (error - last_error) * d;
		motor[motorB] = power + u;
		motor[motorC] = power - u;
		last_error = error;
	}
	
motor[motorB] = 0;
		motor[motorC] = 0;
}
